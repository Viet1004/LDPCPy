# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kMIE40RJjMRAxOQ6Fbk6RZSKX_e48-ig
"""

import numpy as np
import unittest
import random
import time
from LDPC import verification

precr=5
precq=5
#print(f'prec_r: {precr} prec_q: {precq}')

glob=0

def create_input3(lookup, proba):
  for x in lookup:
    # data = Data(neighborC = neighborC, neighborR = neighborR, q_0 = proba[j][0], q_1 = proba[j][1], r_0 = 0, r_1 = 0)
    (i,j) = x
    lookup[x].q_0 = np.log(proba[j][0]/proba[j][1])
    lookup[x].q_1 = proba[j][1]
    #print("x.0? {} x.1 {}".format(a,b))


def current_milli_time():
    return round(time.time() * 1000)



def horizontal_run(lookup, syndrome):
  """
    lookup: table of position of 1 in the parity matrix
    => Update r_0, r_1 
  """
  for x in lookup:
    res = 1
    for row_neighbor in lookup[x].neighborR:
       res *= lookup[row_neighbor].q_0 - lookup[row_neighbor].q_1
    lookup[x].r_0 = round((1+(-1)**syndrome[x[0]]*res)/2,precr)   #(-1)^(syndrom)
    lookup[x].r_1 = round((1-(-1)**syndrome[x[0]]*res)/2,precr)
#  print(lookup)
  return lookup


def vertical_run(lookup, post_proba, string):
  """
    lookup: table of position of 1 in the parity matrix
    post_probo: p_n(x) = P(c_n = x | y_n)
    string: value submitted to change the received codeword
  """
  global glob
  posterioproba = {}
  positionCheck = np.zeros(len(string)) > 1
  for x in lookup:
    q_0 = post_proba[x[1]][0]
    q_1 = post_proba[x[1]][1]
    for col_neighbor in lookup[x].neighborC:
      q_0 *= lookup[col_neighbor].r_0
      q_1 *= lookup[col_neighbor].r_1
    temp = q_0 + q_1
    if temp == 0.0:
      temp = 10**(-1*precq)
      # print(f'q0: {q_0} q_1: {q_1}')
      glob += 1
    lookup[x].q_0 = round(q_0/temp,precq)
    lookup[x].q_1 = round(q_1/temp,precq)
    if not positionCheck[x[1]]:
      q_0 *= lookup[x].r_0
      q_1 *= lookup[x].r_1
      # print(f"At n = {x[1]}, q0 is {q_0}, q1 is {q_1}")
      positionCheck[x[1]] = True
      if q_1 > q_0:
        string[x[1]] = 1
      else:
        string[x[1]] = 0
      # posterioproba[x[1]] = round(q_0/(q_0+q_1),2)
  # print(lookup)
  # print(posterioproba)
  #  print("=======================Posterior Probability===============================")
  # dictionary_item = posterioproba.items()
  # sorted_item = sorted(dictionary_item)
  # print(sorted_item)        # in the screen, we see a tuple of (dict, value), if the value is > 0.5, c_n = 1, otherwise c_n = 0
  return (lookup, string)


def ftanh(w):
  t=np.exp(w)
  return (t-1)/(t+1)


# for both log and min-sum
def horizontal_run2(lookup, syndrome):
  """
    lookup: table of position of 1 in the parity matrix
    => Update r_0, r_1 
  """
  for x in lookup:
    res = 1
    for row_neighbor in lookup[x].neighborR:
       #res *= lookup[row_neighbor].q_0 - lookup[row_neighbor].q_1
       res *= ftanh(lookup[row_neighbor].q_0)
    #lookup[x].r_0 = round((1+(-1)**syndrome[x[0]]*res)/2,precr)   #(-1)^(syndrom)
    #lookup[x].r_1 = round((1-(-1)**syndrome[x[0]]*res)/2,precr)
    lookup[x].r_0 = np.log((1+(-1)**syndrome[x[0]]*res)/(1-(-1)**syndrome[x[0]]*res))
  #print(lookup)
  return lookup


# for bp with log
def horizontal_run3(lookup, syndrome):
  """
    lookup: table of position of 1 in the parity matrix
    => Update r_0, r_1 
  """
  for x in lookup:
    first = lookup[x].neighborR[0]
    sign = lookup[first].q_0 < 0
    mini = np.abs(lookup[first].q_0)
    for row_neighbor in lookup[x].neighborR[1:]:
      sign ^= lookup[row_neighbor].q_0 < 0
      mini = np.min([np.abs(lookup[row_neighbor].q_0),mini])
    sign=(-1)**(int(sign)+syndrome[x[0]])
    lookup[x].r_0 = sign*mini/1.3
  #print(lookup)
  return lookup


# for min sum (with log)
def vertical_run2(lookup, post_proba, string):
  """
    lookup: table of position of 1 in the parity matrix
    post_probo: p_n(x) = P(c_n = x | y_n)
    string: value submitted to change the received codeword
  """
  global glob
  posterioproba = {}
  positionCheck = np.zeros(len(string)) > 1
  for x in lookup:
    q_0 = post_proba[x[1]][0]
    #q_1 = post_proba[x[1]][1]
    q_1 = 1-q_0
    beta=np.log(q_0/q_1)
    for col_neighbor in lookup[x].neighborC:
      #q_0 *= lookup[col_neighbor].r_0
      #q_1 *= lookup[col_neighbor].r_1
      beta += lookup[col_neighbor].r_0
    #temp = q_0 + q_1
    #if temp == 0.0:
      #temp = 10**(-1*precq)
      # print(f'q0: {q_0} q_1: {q_1}')
      #glob += 1
    #lookup[x].q_0 = round(q_0/temp,precq)
    #lookup[x].q_1 = round(q_1/temp,precq)
    lookup[x].q_0 = beta
    if not positionCheck[x[1]]:
      #q_0 *= lookup[x].r_0
      #q_1 *= lookup[x].r_1
      beta += lookup[x].r_0
      # print(f"At n = {x[1]}, q0 is {q_0}, q1 is {q_1}")
      positionCheck[x[1]] = True
      #if q_1 > q_0:
      if beta > 0:
        string[x[1]] = 0
      else:
        string[x[1]] = 1
  return (lookup, string)


# for 'normal' bp
def MessagePassing2(matrix, lookup, postproba, syndrome, number_Iter = 60):
  """
    Algorithm of message passing or belief propagation
  """
  #  if check_cycle(lookup) == False:
  #    print("There is a cycle is size 4 in the matrix")
  #    return (False, None)

  time1=current_milli_time()
  global glob
  Lglob=[]

  _,n = np.shape(matrix)
  string = np.zeros(shape = n, dtype = float)
  for i in range(number_Iter):
    #print("round: {}".format(i))
    #    print("=======================Horizontal Round===========================")
    lookup = horizontal_run(lookup, syndrome)
    #    print("=======================Vertical Round===========================")
    (lookup, string) = vertical_run(lookup, postproba,string)
    if verification(matrix, string, syndrome):
      #    print("success")
      time2=current_milli_time()
      #print("round: {}".format(i))
      time=time2-time1
      #print("time to decode: {} ms".format(time))
      if glob != 0:
        #print(f'glob: {glob} i: {i}')
        Lglob.append(glob)
      glob=0
      if Lglob != []:
        print(f'glob ok: {Lglob}')
      #glob=0
      #return (True, string)
      return (True, i+1, time, string)
    else:
      if glob != 0:
        #print(f'glob: {glob} i: {i}')
        Lglob.append(glob)
      glob=0
      continue
  #print("Failure")
  time2=current_milli_time()
  #print("round: {}".format(i))
  time=time2-time1
  print("time to not decode: {} ms".format(time))
  if Lglob != []:
    print(f'glob fail: {Lglob}')
  #return (False, None)
  return (False, i+1, time, None)

# for bp with log
def MessagePassing3(matrix, lookup, postproba, syndrome, itermp):
  """
    Algorithm of message passing or belief propagation
  """
  #  if check_cycle(lookup) == False:
  #    print("There is a cycle is size 4 in the matrix")
  #    return (False, None)

  time1=current_milli_time()
  global glob
  Lglob=[]

  _,n = np.shape(matrix)
  string = np.zeros(shape = n, dtype = float)
  for i in range(itermp):
    #print("round: {}".format(i))
    #    print("=======================Horizontal Round===========================")
    lookup = horizontal_run2(lookup, syndrome)
    #print(f'lookup: {lookup[0,0]}')
    #    print("=======================Vertical Round===========================")
    (lookup, string) = vertical_run2(lookup, postproba,string)
    #print(f'lookup: {lookup[0,0]}')
    if verification(matrix, string, syndrome):
      #    print("success")
      time2=current_milli_time()
      #print("round: {}".format(i))
      time=time2-time1
      #print("time to decode: {} ms".format(time))
      if glob != 0:
        #print(f'glob: {glob} i: {i}')
        Lglob.append(glob)
      glob=0
      if Lglob != []:
        print(f'glob ok: {Lglob}')
      #glob=0
      #return (True, string)
      return (True, i+1, time, string)
    else:
      if glob != 0:
        #print(f'glob: {glob} i: {i}')
        Lglob.append(glob)
      glob=0
      continue
  #print("Failure")
  time2=current_milli_time()
  #print("round: {}".format(i))
  time=time2-time1
  #print("time to not decode: {} ms".format(time))
  if Lglob != []:
    print(f'glob fail: {Lglob}')
  #return (False, None)
  return (False, i+1, time, None)


# for minsum (with log)
def MessagePassing4(matrix, lookup, postproba, syndrome, itermp):
  """
    Algorithm of message passing or belief propagation
  """
  #  if check_cycle(lookup) == False:
  #    print("There is a cycle is size 4 in the matrix")
  #    return (False, None)


  time1=current_milli_time()
  global glob
  Lglob=[]

  _,n = np.shape(matrix)
  string = np.zeros(shape = n, dtype = float)
  for i in range(itermp):
    #print("round: {}".format(i))
    #    print("=======================Horizontal Round===========================")
    lookup = horizontal_run3(lookup, syndrome)
    #print(f'lookup: {lookup[0,0]}')
    #    print("=======================Vertical Round===========================")
    (lookup, string) = vertical_run2(lookup, postproba,string)
    #print(f'lookup: {lookup[0,0]}')
    if verification(matrix, string, syndrome):
      #    print("success")
      time2=current_milli_time()
      #print("round: {}".format(i))
      time=time2-time1
      #print("time to decode: {} ms".format(time))
      if glob != 0:
        #print(f'glob: {glob} i: {i}')
        Lglob.append(glob)
      glob=0
      if Lglob != []:
        print(f'glob ok: {Lglob}')
      #glob=0
      #return (True, string)
      return (True, i+1, time, string)
    else:
      if glob != 0:
        #print(f'glob: {glob} i: {i}')
        Lglob.append(glob)
      glob=0
      continue
  #print("Failure")
  time2=current_milli_time()
  #print("round: {}".format(i))
  time=time2-time1
  print("time to not decode: {} ms".format(time))
  if Lglob != []:
    print(f'glob fail: {Lglob}')
  #return (False, None)
  return (False, i+1, time, None)



def run_test(matrix, lookup, codeword, crossoverProba, syndrome, bpiter, itertest):

  Ltime=[]
  Lrounds=[]
  success = 0
  false_pos = 0

  for i in range(itertest):
    received, postProba = BSC_channel(codeword, crossoverProba)
    #print(f'received {received}')
    #print(f'postProba {postProba}')

    create_input2(lookup, postProba)
    #print(lookup)

    #verifi, res = MessagePassing2(matrix, lookup, postProba, syndrome)
    verifi, rounds, time, string = MessagePassing2(matrix, lookup, postProba, syndrome, bpiter)
    if verifi:
        #print(res)
        print("ok")
        print(f"rounds: {rounds}")
        Ltime.append(time)
        Lrounds.append(rounds)
        if np.array_equal(string,codeword):
          success += 1
        else:
          false_pos += 1

    else:
        print("Fail to decode")
        print(f"rounds: {rounds}")

  if Ltime != []:
    mean_rounds = sum(Lrounds)/len(Lrounds)
    print(f'mean rounds: {round(mean_rounds,2)} min: {min(Lrounds)} max: {max(Lrounds)}')
    mean_time = sum(Ltime)/len(Ltime)
    print(f'mean time: {round(mean_time/1000,3)} sec ({round(mean_time/mean_rounds/1000,3)} sec / round)')
  print(f'success: {success} / {itertest}')
  print(f'false_pos: {false_pos} / {itertest}')
  print(' ')
  print(' ')

