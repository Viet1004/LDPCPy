# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kMIE40RJjMRAxOQ6Fbk6RZSKX_e48-ig
"""

# Z ~ q, L ~ r

import numpy as np
import unittest
import random
from numpy.ma.core import shape
from scipy.sparse import csr_matrix, data, coo_matrix
from scipy.sparse import vstack
#from numba import jit
import math

cnt_nan = 0
cnt_zero = 0
cnt_temp1 = 0
match_fail = 0
match_success = 0

class Data:
  def __init__(self, neighborC, neighborR, q_0 = 1 , r_0 = 1):
    self.neighborC = neighborC
    self.neighborR = neighborR
    self.q_0 = q_0
    self.r_0 = r_0
#    || 0 || 1 || 2 || 3 || 4 || 5 || 6 || 7 ||
#      0,1  1,3 
   
  def __repr__(self):
    return f'neighborC: {self.neighborC} \n neighborR: {self.neighborR} \n ({self.q_0}) \n ({self.r_0}) \n'

class Data_MinSum:
  def __init__(self, neighborC, neighborR, L, Z):
    self.neighborC = neighborC
    self.neighborR = neighborR
    self.L = L
    self.Z = Z

#@jit(nopython = True)
def BFS_simple(graph, node, m,n):
  """
  This one only works for our purpose!!! It's not a BFS algo in general
  Output: The set of checknode which are not included in the tree of node (sort of)
  """
  checkPassed = []
  queueCheck = []
  variablePassed = [node]
  queueVariable = [node]
  while(True):
    temp1 = []
    temp2 = []
    for variableNode in queueVariable:
      temp1 = list(set(temp1) | set(graph[variableNode]))
#    print(f"Node: {node}, graph: {graph}")
    temp1 = list(set(temp1) | set(checkPassed))
    if set(temp1) == set([i for i in np.arange(n,m+n, dtype=int)]) or set(temp1) == set(checkPassed):
#      print("About to return:")
#      print(set([x for x in np.arange(n,n+m)]))
#      print(list(set([x for x in np.arange(n,n+m)]) - set(checkPassed)))
      return list(set([x for x in np.arange(n,n+m)]) - set(checkPassed))
    else:
      queueCheck = list(set(temp1) - set(checkPassed))
      checkPassed = temp1
#      print("Check node Queue")    
#      print(queueCheck)
#      print(checkPassed)
#    print("===========This is between checknode and variablenode==============")
    for checkNode in queueCheck:
      temp2 = list(set(temp2) | set(graph[checkNode]))
    temp2 = list(set(temp2) | set(variablePassed))
    queueVariable = list(set(temp2) - set(variablePassed))
    variablePassed = temp2
#@jit
def matrix_generation_PEG(degreeOfVNode, m, n):
  checkNode = np.zeros(m)
  graph = []
  for i in range(n+m):
    graph.append([])
  data = np.ones(np.sum(degreeOfVNode), dtype=np.int8)
  row = np.array([], dtype=int)
  col = np.array([], dtype=int)
  for i in range(n):
#    print(f"=====================  i = {i}  ========================")
    for j in range(degreeOfVNode[i]):
      if j == 0:
        ind = np.argmin(checkNode)
        checkNode[ind] += 1
        row = np.append(row, ind)
        col = np.append(col, i)
        graph[i].append(int(n+ind))
        graph[n+ind].append(i)
      else:
#        print("Inside BFS")
        complementCheckNode = [x - n for x in BFS_simple(graph, i, m,n)]
#        print("End of BFS")
#        print("==================================")
#        print(complementCheckNode)
#        print("==================================")
        degreeOfLeftCheckNode = [checkNode[x] for x in complementCheckNode]
#        print(degreeOfLeftCheckNode)
        ind = complementCheckNode[list(degreeOfLeftCheckNode).index(min(degreeOfLeftCheckNode))]
#        print(f"index chosen is : {ind}")
        checkNode[ind] += 1
#        print(f"degree of all check node is : {checkNode}")
        row = np.append(row, ind)
        col = np.append(col, i)    
        graph[i].append(n+ind)
        graph[n+ind].append(i)
#      print(checkNode)
  return coo_matrix((data, (row, col)), dtype=np.int8).tocsr()

#@jit(nopython = True)
def matrix_generation(n: int,w_c :int, w_r: int, seed):
  """
    w_c: weight of column (number of one in a column)
    w_r: weight of row (number of one in a row)
    n: size of code
    seed: to make permutation
    note: w_c < w_r
  """
  data = np.ones(n)
  indptr = np.arange(0,n+1,w_r)
  indices = np.arange(n)
  matrix = csr_matrix((data,indices,indptr), dtype=float)
  for i in range(w_c -1):
    temp = np.copy(indices)
    np.random.RandomState(seed = seed*i).shuffle(temp)
    matrix = vstack([matrix,csr_matrix((data, temp, indptr), dtype=float)])
  return matrix


# =============== Create irregular matrix with rate = 0.75 ========================
#rate = 0.75
def matrix_generation_test(m,n):
  lookup_table = {31:0.47408,28:0.01107,7:0.05288,6:0.10667, 5:0.13764, 4:0.01449, 3: 0.18088, 2:0.10805 }

  denominator = lambda a: sum([a[i]/i for i in a])
  denom = denominator(lookup_table)
  Dv = np.zeros(n,dtype = np.int16)
  placetaken = 0
  for x in lookup_table:
    if x == 2:
      Dv[placetaken:n] = x
    else:
      number = round(n*lookup_table[x]/(x*denom))
      if number == 0:
        number = 1
      Dv[placetaken:placetaken+number] = x
      placetaken += number
  return Dv


# =============== End of matrix generation ========================================


# =============== This change might improve speed of the code =====================
def matrix_generation_regularLDPC(n: int,w_c :int, w_r: int,seed):
  indptr = np.arange(0,n+1,w_r)
  indices = np.arange(n)
  data = np.ones(n*w_c, dtype=float)
  matrix = csr_matrix((data,indices,indptr), dtype=float)
  for i in range(w_c -1):
    temp = np.copy(indices)
    np.random.RandomState(seed = seed*i).shuffle(temp)
    matrix = vstack([matrix,csr_matrix((data, temp, indptr), dtype=float)])
  return matrix

#@jit(nopython = True)
def input_generation_regularLDPC(matrix, postProba):
  """
    w_c: weight of column (number of one in a column)
    w_r: weight of row (number of one in a row)
    n: size of code
    seed: to make permutation
    note: w_c < w_r
  """
  matrix.data = np.array([np.log(postProba[x]/(1-postProba[x])) for x in matrix.indices])

def new_horizontal_run(matrix, syndrome):
  global cnt_nan
  global cnt_zero
  indptr = matrix.indptr
  # indices = matrix.indices
  data = np.tanh(matrix.data/2)
  # dumpInd = 0
  for index in range(len(indptr)-1):
    start = indptr[index]
    end = indptr[index+1]
    if start == end:
      continue
    temp1 = np.copy(data[start:end])
    T=np.where(temp1==0)
    if len(T[0]) != 0:
      print(f'temp1: {len(T[0])}')
      cnt_temp1 += 1
      temp1[T]=10**(-5)
    prodTemp = temp1.prod()
    if np.isnan(prodTemp):
      #print("We are fucked again!")
      prodTemp = 0
      cnt_nan += 1
      continue
    for i in range(end - start):
      temp2 = prodTemp/temp1[i]*(-1)**syndrome[index]
      # print(type(temp2))
      if np.abs(temp2) == 1.0:
        temp2 = temp2-np.sign(temp2)*10**(-10)
        cnt_zero += 1
      matrix.data[start+i] = np.log((1+temp2)/(1-temp2))
    # this line is never reached if continue at range - 1
    # if end == indptr[-1]:
    #   break
  #print(f'matrix: {matrix.data}')
  return matrix

#@jit(nopython = True)
def new_vertical_run(matrix, postProba,n):
  matrix = matrix.tocsc()
  indptr = matrix.indptr
#  indices = matrix.indices
  data = matrix.data

#  print(postProba)
  beta = np.zeros(n)
  for index in range(len(indptr)):
    start = indptr[index]
    end = indptr[index +1]    
    temp1 = np.copy(data[start:end])
    beta[index] = temp1.sum() + postProba[index]
    for i in range(end- start):
      matrix.data[start+i] = beta[index] - temp1[i]
    if end == len(data):
      break
  string=np.array(beta<=0)
  string=string.astype(int)
  #print(f'matrix {matrix.data}')
  return (matrix.tocsr(), string)

#@jit
def new_MessagePassing(matrix,postProba,syndrome, n, numberIter = 60):
  global cnt_zero
  global cnt_temp1
  global match_fail
  global match_success

  input_generation_regularLDPC(matrix, postProba)
  #print(f'matrix {matrix}')
  matrix0 = csr_matrix((np.ones(len(matrix.data), dtype=np.int8),matrix.indices,matrix.indptr), dtype = np.int8)
  #print(f'matrix0 {matrix0}')
  #postProba = data = np.array([np.log(x/(1-x)) for x in postProba])
  postProba=np.log(postProba/(1-postProba))
  #print(f'postProba: {postProba}')
  for i in range(numberIter):
    #print("horizontal")
    matrix = new_horizontal_run(matrix, syndrome)
    #print("===================================")
    #print(f'matrix {matrix}')
    # print("===================================")
    #print("vertical")
    matrix,string = new_vertical_run(matrix,postProba,n)
    # print(matrix.toarray())
    verifi = verification(matrix0,string,syndrome)
    if verifi == True:
      print(f"The number of Iteration is {i+1}")
      print(f'cnt_nan: {cnt_nan} cnt_zerot1: {cnt_temp1} cnt_zerot2: {cnt_zero}')
      if cnt_zero != 0:
        match_success += 1
      cnt_zero = 0
      cnt_temp1 = 0
      return True, i+1, string, match_fail, match_success
  print(f'cnt_nan: {cnt_nan} cnt_zerot1: {cnt_temp1} cnt_zerot2: {cnt_zero}')
  if cnt_zero != 0:
    match_fail += 1
  cnt_zero = 0
  cnt_temp1 = 0
  return False, i+1, string, match_fail, match_success


# =============== End of change ===================================================
#@jit
def BSC_channel(code, crossoverProba: float):
  n = code.shape[0]
  res = np.copy(code)
  postProba = []
  for i in range(n):
    if random.random() < crossoverProba:
      res[i] = int((code[i]+1)%2)
    # if res[i] == 0:
    #   postProba.append(1-crossoverProba)
    # else:
      postProba.append(crossoverProba)

  # this is much faster
  postProba = np.array([])
  postProba=(1-res)*(1-crossoverProba)+res*crossoverProba
  return res, postProba

def create_lookup(matrix):
  m,n = matrix.get_shape()
  lookup = {}
  # we first remap the row of H to the neighborR of the lookup 
  for i in range(m):
    R = matrix.getrow(i).tocoo().col
    w_r = len(R)
    for k in range(w_r):
      neighborR1 = np.delete(R,k) 
      neighborR = []
      for l in range(w_r-1):
        neighborR.append((i,neighborR1[l]))
      data = Data(neighborC = [], neighborR = neighborR, q_0 = 0, r_0 = 0)
      lookup[(i,R[k])] = data
      #print(lookup)
  for x in lookup:
    if not lookup[x].neighborC:
      (i,j) = x
      #print(f'x {x}')
      C = matrix.getcol(j).tocoo().row
      w_c = len(C)
      for k in range(w_c):
        neighborC1 = np.delete(C,k) 
        neighborC = []
        for l in range(w_c-1):
          neighborC.append((neighborC1[l],j))
        data = lookup[(C[k],j)]
        data.neighborC = neighborC
  return lookup

# then we remap the columns of H to the neighborR field of the lookup

def create_input(lookup, proba):
#  string = np.zeros(shape= n , dtype=float)
  for key in lookup:
      lookup[key].q_0 = proba[key[1]]
      

#  for key in lookup:
#    print(f'key:{key}, value: {lookup[key]} \n')
  return lookup

#Create input for log function
def create_input_log(lookup, proba):
  for key in lookup:
    lookup[key].q_0 = math.log(proba[key[1]]/(1-proba[key[1]]))
  return lookup

def count_cycle_size_four(lookup: dict):
  checkedNode = []
  cycleSizeFour = 0
  for x in lookup:
    checkedNode.append(x)
    for neighbor_row in lookup[x].neighborR:
      if neighbor_row in checkedNode:
        continue
      for neighbor_col in lookup[neighbor_row].neighborC:
        if neighbor_row in checkedNode:
          continue
        for neighbor_row2 in lookup[neighbor_col].neighborR:
          if neighbor_row2 in checkedNode:
            continue
          for neighbor_col2 in lookup[neighbor_row2].neighborC:
            if neighbor_col2 == x:
              cycleSizeFour += 1
  return cycleSizeFour

# Log likelihood implementation

def horizontal_run_log(lookup, syndrome):
#  print("Before horizontal operation:")
  row = [x[0] for x in lookup]
  
  col = [x[1] for x in lookup]
  
  data = [lookup[x].q_0 for x in lookup]
  matrix = coo_matrix((data, (row,col)))
  for x in lookup:
    res = 1
    for row_neighbor in lookup[x].neighborR:
      res *= math.tanh(lookup[row_neighbor].q_0/2)
#    print(f"Res is :{res}")
    lookup[x].r_0 = ((-1)**syndrome[x[0]])*2*math.atanh(res)
#  print(lookup)

  data = [lookup[x].r_0 for x in lookup]
  
  matrix = coo_matrix((data, (row,col)))
#  print(matrix.toarray())
  return lookup

def horizontal_run_log_MinSum(lookup, syndrome):
  for x in lookup:
    res = 1
    minZ = np.inf
    for row_neighbor in lookup[x].neighborR:
#      res *= math.tanh(lookup[row_neighbor].q_0/2)
      if minZ > lookup[row_neighbor].q_0:
        minZ = lookup[row_neighbor].q_0
      res *= np.sign(lookup[row_neighbor].q_0)
#    print(f"Res is :{res}")
    lookup[x].r_0 = minZ*(-1)**syndrome[x[0]]
  print(lookup)
  return lookup


def horizontal_run(lookup, syndrome):
  """
    lookup: table of position of 1 in the parity matrix
    => Update r_0, r_1 
  """
  for x in lookup:
    res = 1
    for row_neighbor in lookup[x].neighborR:
       res *= 2*lookup[row_neighbor].q_0 - 1
    lookup[x].r_0 = (1+(-1)**syndrome[x[0]]*res)/2   #(-1)^(syndrom)
#    lookup[x].r_1 = round((1-(-1)**syndrome[x[0]]*res)/2,5)
#  print(lookup)
  return lookup

#Log likelihood implementation
def vertical_run_log(lookup, Post_proba, string):
  positionCheck = np.zeros(len(string)) > 1
  for x in lookup:
    Z = math.log(Post_proba[x[1]]/(1-Post_proba[x[1]]))
    for col_neighbor in lookup[x].neighborC:
      Z += lookup[col_neighbor].r_0     # Z ~ q, L ~ r
    lookup[x].q_0 = Z
    if not positionCheck[x[1]]:
      Z += lookup[x].r_0
      positionCheck[x[1]] = True
      if Z >= 0:
        string[x[1]] = 0
      else:
        string[x[1]] = 1
  row = [x[0] for x in lookup]
  
  col = [x[1] for x in lookup]
  
  data = [lookup[x].q_0 for x in lookup]
  
  matrix = coo_matrix((data, (row,col)))
#  print(matrix.toarray())
  
#  print(lookup)
  return (lookup, string)

def vertical_run(lookup, post_proba, string):
  """
    lookup: table of position of 1 in the parity matrix
    post_probo: p_n(x) = P(c_n = x | y_n)
    string: value submitted to change the received codeword
  """
  posterioproba = {}
  positionCheck = np.zeros(len(string)) > 1
  for x in lookup:
    q_0 = post_proba[x[1]]
    q_1 = 1 - post_proba[x[1]]
    for col_neighbor in lookup[x].neighborC:
      q_0 *= lookup[col_neighbor].r_0
      q_1 *= 1 - lookup[col_neighbor].r_0
    temp = q_0 + q_1
    lookup[x].q_0 = q_0/temp
    if not positionCheck[x[1]]:
      q_0 = lookup[x].r_0*q_0/(lookup[x].r_0*q_0+(1-lookup[x].r_0)*(1-q_0))
#    print(f"At n = {x[1]}, q0 is {q_0}, q1 is {q_1}")
      positionCheck[x[1]] = True
      if q_0 < 0.5 :
        string[x[1]] = 1
      else:
        string[x[1]] = 0
  return (lookup, string)

def verification(matrix, check, syndrome):
  """
    matrix: Parity check matrix
    check: the string after vertical run
    => check if Hc = syndrome
  """ 
  return not np.any((matrix.dot(check)-syndrome)%2)

def MessagePassing_log(lookup,matrix, proba, syndrome, number_Iter = 60):
  """
    Algorithm of message passing or belief propagation
  """
#  lookup = create_input(matrix, proba)
  _,n = np.shape(matrix)  
  string = np.zeros(shape = n, dtype = np.int8)
  for i in range(number_Iter):
#    print("round: {}".format(i))
#    print("=======================Horizontal Round===========================")
    lookup = horizontal_run_log(lookup, syndrome)
#    print("=======================Vertical Round===========================")
    (lookup, string) = vertical_run_log(lookup, proba,string)
    if verification(matrix, string, syndrome):
  #    print("success")
      print(f"The number of Iteration is : {i}")
      return (True, string)
    else:
      continue
  #print("Failure")
  return (False, None)

def MessagePassing(lookup,matrix, proba, syndrome, number_Iter = 1):
  """
    Algorithm of message passing or belief propagation
  """
#  lookup = create_input(matrix, proba)
  _,n = np.shape(matrix)  
  string = np.zeros(shape = n, dtype = np.int8)
  for i in range(number_Iter):
    lookup = horizontal_run(lookup, syndrome)
#    print("=======================Vertical Round===========================")
    (lookup, string) = vertical_run(lookup, proba,string)
    if verification(matrix, string, syndrome):
  #    print("success")
      print(f"The number of Iteration is : {i}")
      return (True, string)
    else:
      continue
  #print("Failure")
  return (False, None)

class TestSum(unittest.TestCase):
  matrix = np.array([[1,0,1,1,0,1,0,0],[1,1,0,1,0,0,0,1],[0,0,0,0,1,1,1,1],[0,1,1,0,1,0,1,0]])
  proba = [(0.1,0.9),(0.9,0.1),(0.1,0.9),(0.1,0.9),(0.9,0.1),(0.1,0.9),(0.9,0.1),(0.1,0.9)]
  
#  def test_verification_true(self):
#    self.assertEqual(verification(matrix = matrix,check = [1,1,1,1,0,1,0,1]), True , " Should be True")

 # def test_verification_false(self):
#    self.assertEqual(verification(matrix = [[0,1,0,1,1,0],[0,0,1,1,0,0]], check = [0,1,0,0,0,0]), False, " Should be False")

#  def test_check_cycle1(self):
#    lookup = create_lookup(np.array([[1,1,1,1,0,0,0,0],[0,0,0,0,1,1,1,1],[1,0,0,0,0,0,1,0],[0,0,0,1,0,0,0,1]]))
#    self.assertEqual(check_cycle(lookup), True, "Should have cycle of size 4")

#  def test_check_cycle2(self):
#    lookup = create_lookup(np.array([[1,0,1,0,1,0],[0,1,0,1,0,1]]))
#    self.assertEqual(check_cycle(lookup), True, "Should have no cycle of size 4")
"""
  def test_create_matrix(self):
    matrix = np.array([[1,0,0,1],[0,1,1,0]])
    proba = [(0.1,0.9),(0.9,0.1),(0.1,0.9),(0.1,0.9)]
    data1 = Data([],[],0.1,0.9,0,0)
    data2 = Data([],[],0.9,0.1,0,0)
    self.assertDictEqual(create_input(matrix, proba), {(0,0):Data([],[(0,3)],0.1,0.9,0,0), (0,3): Data([],[(0,0)],0.1,0.9,0,0),(1,1):Data([],[(1,2)],0.9,0.1,0,0),(1,2):Data([],[(1,1)],0.1,0.9,0,0)}, "should be equal")  
"""
"""
  def test_horizontal_run(self):
    lookup = create_input(matrix, proba)
    a_plus = (1+(0.8)**3)/2
    a_minus = (1-(0.8)**3)/2
    self.assertDictEqual(horizontal_run(lookup))
"""
#  def test_horizontal_run(self):
#    self.assertEqual()
if __name__ == '__main__':
  unittest.main()
"""
  print("============================================================================")
  lookup = horizontal_run(lookup)
  for key in lookup:
    print(f'key:{key}, value: {lookup[key]} \n')
  print("============================================================================")
  lookup, string = vertical_run(lookup, proba, string)
  for key in lookup:
    print(f'key:{key}, value: {lookup[key]} \n')
  for car in string:
    print(f"{car} \t")
"""

