# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kMIE40RJjMRAxOQ6Fbk6RZSKX_e48-ig
"""

import numpy as np
import unittest
import random
from scipy.sparse import csr_matrix, data 
from scipy.sparse import vstack

class Data:
  def __init__(self, neighborC, neighborR, q_0 = 1 , q_1 = 1, r_0 = 1, r_1 = 1):
    self.neighborC = neighborC
    self.neighborR = neighborR
    self.q_0 = q_0
    self.q_1 = q_1
    self.r_0 = r_0
    self.r_1 = r_1
#    || 0 || 1 || 2 || 3 || 4 || 5 || 6 || 7 ||
#      0,1  1,3 
   
  def __repr__(self):
    return f'neighborC: {self.neighborC} \n neighborR: {self.neighborR} \n ({self.q_0},{self.q_1}) \n ({self.r_0,self.r_1}) \n'

def matrix_generation(n: int,w_c :int, w_r: int, seed):
  """
    w_c: weight of column (number of one in a column)
    w_r: weight of row (number of one in a row)
    n: size of code
    seed: to make permutation
    note: w_c < w_r
  """
  
#  while(n % w_r != 0):
#    print("Please make sure that w_r divides n!")
#  m = n*w_c/w_r
#  matrix = np.zeros((n//w_r, n), dtype=int)
#  matrix_clone = np.copy(matrix)
#  for i in range(n//w_r):
#    matrix[i][i*w_r:(i+1)*w_r] = 1
#  matrix_clone = np.copy(matrix)
#  for i in range(w_c-1):
#    b = np.random.RandomState(seed = seed*i).permutation(n)
#    temp = np.zeros((n//w_r, n), dtype=int)
#    for j in range(n):
#      temp[:,j] = matrix_clone[:,b[j]]
#    matrix = np.concatenate((matrix, temp), axis = 0)
#  return matrix
  data = np.ones(n)
  indptr = np.arange(0,n+1,w_r)
  indices = np.arange(n)
  matrix = csr_matrix((data,indices,indptr))
  for i in range(w_c -1):
    temp = np.copy(indices)
    np.random.RandomState(seed = seed*i).shuffle(temp)
    matrix = vstack([matrix,csr_matrix((data, temp, indptr))])
  return matrix

def BSC_channel(code, crossoverProba: float):
  n = code.shape[0]
  res = np.copy(code)
  postProba = []
  for i in range(n):
    if random.random() < crossoverProba:
      res[i] = int((code[i]+1)%2)
    if res[i] == 0:
      postProba.append((1-crossoverProba, crossoverProba))
    else:
      postProba.append((crossoverProba, 1- crossoverProba))
  return res, postProba

def create_lookup(matrix,w_r, w_c):
#  m,n = np.shape(matrix)
#  lookup = {}
##  string = np.zeros(shape= n , dtype=float)
#  for i in range(m):
#    for j in range(n):
#      if matrix[i][j] == 1:
#        neighborR = []
#        neighborC = []
#        for k in range(n):
#          if matrix[i][k] == 1 and j != k:    
#            neighborR.append((i,k))
#        for k in range(m):
#          if matrix[k][j] == 1 and i != k:
#            neighborC.append((k,j))
#        data = Data(neighborC = neighborC, neighborR= neighborR)
#        lookup[(i,j)] = data
#  return lookup

  m,n = matrix.get_shape()
  lookup = {}
  # we first remap the row of H to the neighborR of the lookup 
  for i in range(m):
    R = matrix.getrow(i).tocoo().col
    for k in range(w_r):
      neighborR1 = np.delete(R,k) 
      neighborR = []
      for l in range(w_r-1):
        neighborR.append((i,neighborR1[l]))
      data = Data(neighborC = [], neighborR = neighborR, q_0 = 0, q_1 = 0, r_0 = 0, r_1 = 0)
      lookup[(i,R[k])] = data
      #print(lookup)
  for x in lookup:
    if not lookup[x].neighborC:
      (i,j) = x
      #print(f'x {x}')
      C = matrix.getcol(j).tocoo().row
      for k in range(w_c):
        neighborC1 = np.delete(C,k) 
        neighborC = []
        for l in range(w_c-1):
          neighborC.append((neighborC1[l],j))
        data = lookup[(C[k],j)]
        data.neighborC = neighborC
  return lookup

# then we remap the columns of H to the neighborR field of the lookup

def create_input(lookup, proba):
#  string = np.zeros(shape= n , dtype=float)
  for key in lookup:
      lookup[key].q_0 = proba[key[1]][0]
      lookup[key].q_1 = proba[key[1]][1]

#  for key in lookup:
#    print(f'key:{key}, value: {lookup[key]} \n')
  return lookup

def check_cycle(lookup: dict):
  check_node = []
  for x in lookup:
    check_node.append(x)
    for neighbor_row in lookup[x].neighborR:
      if neighbor_row in check_node:
        continue
      for neighbor_col in lookup[neighbor_row].neighborC:
        if neighbor_row in check_node:
          continue
        for neighbor_row2 in lookup[neighbor_col].neighborR:
          if neighbor_row2 in check_node:
            continue
          for neighbor_col2 in lookup[neighbor_row2].neighborC:
            if neighbor_col2 == x:
              return False
  return True

def horizontal_run(lookup, syndrome):
  """
    lookup: table of position of 1 in the parity matrix
    => Update r_0, r_1 
  """
  for x in lookup:
    res = 1
    for row_neighbor in lookup[x].neighborR:
       res *= lookup[row_neighbor].q_0 - lookup[row_neighbor].q_1
    lookup[x].r_0 = round((1+(-1)**syndrome[x[0]]*res)/2,5)   #(-1)^(syndrom)
    lookup[x].r_1 = round((1-(-1)**syndrome[x[0]]*res)/2,5)
#  print(lookup)
  return lookup

def vertical_run(lookup, post_proba, string):
  """
    lookup: table of position of 1 in the parity matrix
    post_probo: p_n(x) = P(c_n = x | y_n)
    string: value submitted to change the received codeword
  """
  posterioproba = {}
  positionCheck = np.zeros(len(string)) > 1
  for x in lookup:
    q_0 = post_proba[x[1]][0]
    q_1 = post_proba[x[1]][1]
    for col_neighbor in lookup[x].neighborC:
      q_0 *= lookup[col_neighbor].r_0
      q_1 *= lookup[col_neighbor].r_1
    temp = q_0 + q_1
    lookup[x].q_0 = round(q_0/temp,5)
    lookup[x].q_1 = round(q_1/temp,5)
    if not positionCheck[x[1]]:
      q_0 *= lookup[x].r_0
      q_1 *= lookup[x].r_1
#    print(f"At n = {x[1]}, q0 is {q_0}, q1 is {q_1}")
      positionCheck[x[1]] = True
    if q_1 > q_0:
      string[x[1]] = 1
    else:
      string[x[1]] = 0
#    posterioproba[x[1]] = round(q_0/(q_0+q_1),2)
#  print(lookup)
#  print(posterioproba)
#  print("=======================Posterior Probability===============================")
#  dictionary_item = posterioproba.items()
#  sorted_item = sorted(dictionary_item)
#  print(sorted_item)        # in the screen, we see a tuple of (dict, value), if the value is > 0.5, c_n = 1, otherwise c_n = 0
  return (lookup, string)

def verification(matrix, check, syndrome):
  """
    matrix: Parity check matrix
    check: the string after vertical run
    => check if Hc = syndrome
  """ 
  return not np.any((matrix.dot(check)-syndrome)%2)

def MessagePassing(lookup,matrix, proba, syndrome, number_Iter = 60):
  """
    Algorithm of message passing or belief propagation
  """
#  lookup = create_input(matrix, proba)
  _,n = np.shape(matrix)
  
#  if check_cycle(lookup) == False:
#    print("There is a cycle is size 4 in the matrix")
#    return (False, None)
  
  string = np.zeros(shape = n, dtype = float)
  for i in range(number_Iter):
#    print("round: {}".format(i))
#    print("=======================Horizontal Round===========================")
    lookup = horizontal_run(lookup, syndrome)
#    print("=======================Vertical Round===========================")
    (lookup, string) = vertical_run(lookup, proba,string)
    if verification(matrix, string, syndrome):
  #    print("success")
      return (True, string)
    else:
      continue
  #print("Failure")
  return (False, None)

class TestSum(unittest.TestCase):
  matrix = np.array([[1,0,1,1,0,1,0,0],[1,1,0,1,0,0,0,1],[0,0,0,0,1,1,1,1],[0,1,1,0,1,0,1,0]])
  proba = [(0.1,0.9),(0.9,0.1),(0.1,0.9),(0.1,0.9),(0.9,0.1),(0.1,0.9),(0.9,0.1),(0.1,0.9)]
  
#  def test_verification_true(self):
#    self.assertEqual(verification(matrix = matrix,check = [1,1,1,1,0,1,0,1]), True , " Should be True")

 # def test_verification_false(self):
#    self.assertEqual(verification(matrix = [[0,1,0,1,1,0],[0,0,1,1,0,0]], check = [0,1,0,0,0,0]), False, " Should be False")

#  def test_check_cycle1(self):
#    lookup = create_lookup(np.array([[1,1,1,1,0,0,0,0],[0,0,0,0,1,1,1,1],[1,0,0,0,0,0,1,0],[0,0,0,1,0,0,0,1]]))
#    self.assertEqual(check_cycle(lookup), True, "Should have cycle of size 4")

#  def test_check_cycle2(self):
#    lookup = create_lookup(np.array([[1,0,1,0,1,0],[0,1,0,1,0,1]]))
#    self.assertEqual(check_cycle(lookup), True, "Should have no cycle of size 4")
"""
  def test_create_matrix(self):
    matrix = np.array([[1,0,0,1],[0,1,1,0]])
    proba = [(0.1,0.9),(0.9,0.1),(0.1,0.9),(0.1,0.9)]
    data1 = Data([],[],0.1,0.9,0,0)
    data2 = Data([],[],0.9,0.1,0,0)
    self.assertDictEqual(create_input(matrix, proba), {(0,0):Data([],[(0,3)],0.1,0.9,0,0), (0,3): Data([],[(0,0)],0.1,0.9,0,0),(1,1):Data([],[(1,2)],0.9,0.1,0,0),(1,2):Data([],[(1,1)],0.1,0.9,0,0)}, "should be equal")  
"""
"""
  def test_horizontal_run(self):
    lookup = create_input(matrix, proba)
    a_plus = (1+(0.8)**3)/2
    a_minus = (1-(0.8)**3)/2
    self.assertDictEqual(horizontal_run(lookup))
"""
#  def test_horizontal_run(self):
#    self.assertEqual()
if __name__ == '__main__':
  unittest.main()
"""
  print("============================================================================")
  lookup = horizontal_run(lookup)
  for key in lookup:
    print(f'key:{key}, value: {lookup[key]} \n')
  print("============================================================================")
  lookup, string = vertical_run(lookup, proba, string)
  for key in lookup:
    print(f'key:{key}, value: {lookup[key]} \n')
  for car in string:
    print(f"{car} \t")
"""

